module Graphql_ppx_runtime = {
  // mock
  let deepMerge = (json1, _) => json1
}
module ListFragment: {
  @@ocaml.warning("-32-30")
  module Raw: {
    type rec t = {nullableOfNullable: Nullable.t<array<Nullable.t<string>>>}
    type t_Lists = t
  }
  type rec t = {nullableOfNullable: option<array<option<string>>>}
  type t_Lists = t
  @ocaml.doc(" the GraphQL fragment ") let query: string
  @ocaml.doc(" Parse the raw JSON-compatible GraphQL data into ReasonML data types ")
  let parse: Raw.t => t
  @ocaml.doc(" Serialize the ReasonML GraphQL data that was parsed using the parse
function back to the original JSON-compatible data ")
  let serialize: t => Raw.t
  let verifyArgsAndParse: (~fragmentName: [#ListFragment], Raw.t) => t
  let verifyName: [#ListFragment] => unit
  external unsafe_fromJson: JSON.t => Raw.t = "%identity"
  external toJson: Raw.t => JSON.t = "%identity"
} = {
  @@ocaml.warning("-32-30")
  module Raw = {
    type rec t = {nullableOfNullable: Nullable.t<array<Nullable.t<string>>>}
    type t_Lists = t
  }
  type rec t = {nullableOfNullable: option<array<option<string>>>}
  type t_Lists = t
  let query = "fragment ListFragment on Lists   {
nullableOfNullable  
}
"
  let parse = (value): t => {
    nullableOfNullable: {
      let value = (value: Raw.t).nullableOfNullable
      switch Nullable.toOption(value) {
      | Some(value) =>
        Some(
          @res.uapp
          Array.map(value, value =>
            switch Nullable.toOption(value) {
            | Some(value) => Some(value)
            | None => None
            }
          ),
        )
      | None => None
      }
    },
  }
  let serialize = (value): Raw.t => {
    let nullableOfNullable = {
      let value = (value: t).nullableOfNullable
      switch value {
      | Some(value) =>
        Nullable.make(
          @res.uapp
          Array.map(value, value =>
            switch value {
            | Some(value) => Nullable.make(value)
            | None => Nullable.null
            }
          ),
        )
      | None => Nullable.null
      }
    }
    {nullableOfNullable: nullableOfNullable}
  }
  let verifyArgsAndParse = (~fragmentName as _ListFragment: [#ListFragment], value: Raw.t) =>
    parse(value)
  let verifyName = (_fragmentName: [#ListFragment]) => ()
  external unsafe_fromJson: JSON.t => Raw.t = "%identity"
  external toJson: Raw.t => JSON.t = "%identity"
}
module Another: {
  @@ocaml.warning("-32-30")
  module Raw: {
    type rec t
    type t_Lists = t
  }
  type rec t = {
    nullableOfNullable: option<array<option<string>>>,
    listFragment: ListFragment.t_Lists,
  }
  type t_Lists = t
  @ocaml.doc(" the GraphQL fragment ") let query: string
  @ocaml.doc(" Parse the raw JSON-compatible GraphQL data into ReasonML data types ")
  let parse: Raw.t => t
  @ocaml.doc(" Serialize the ReasonML GraphQL data that was parsed using the parse
function back to the original JSON-compatible data ")
  let serialize: t => Raw.t
  let verifyArgsAndParse: (~fragmentName: [#Another], Raw.t) => t
  let verifyName: [#Another] => unit
  external unsafe_fromJson: JSON.t => Raw.t = "%identity"
  external toJson: Raw.t => JSON.t = "%identity"
} = {
  @@ocaml.warning("-32-30")
  module Raw = {
    type rec t
    type t_Lists = t
  }
  type rec t = {
    nullableOfNullable: option<array<option<string>>>,
    listFragment: ListFragment.t_Lists,
  }
  type t_Lists = t
  let query = \"++"(
    "fragment Another on Lists   {
nullableOfNullable  
...ListFragment   
}
",
    ListFragment.query,
  )
  let parse = (value): t => {
    nullableOfNullable: {
      let value = Obj.magic(Dict.getUnsafe(Obj.magic(value), "nullableOfNullable"))
      switch Nullable.toOption(value) {
      | Some(value) =>
        Some(
          @res.uapp
          Array.map(value, value =>
            switch Nullable.toOption(value) {
            | Some(value) => Some(value)
            | None => None
            }
          ),
        )
      | None => None
      }
    },
    listFragment: {
      let value = (Obj.magic(value): ListFragment.Raw.t)

      @res.uapp
      ListFragment.verifyArgsAndParse(~fragmentName=#ListFragment, value)
    },
  }
  let serialize = (value): Raw.t =>
    Obj.magic(
      Array.reduce(
        [(Obj.magic(ListFragment.serialize((value: t).listFragment)): JSON.t)],
        (
          Obj.magic({
            let nullableOfNullable = {
              let value = (value: t).nullableOfNullable
              switch value {
              | Some(value) =>
                Nullable.make(
                  @res.uapp
                  Array.map(value, value =>
                    switch value {
                    | Some(value) => Nullable.make(value)
                    | None => Nullable.null
                    }
                  ),
                )
              | None => Nullable.null
              }
            }
            {"nullableOfNullable": nullableOfNullable}
          }): JSON.t
        ),
        Graphql_ppx_runtime.deepMerge,
      ),
    )
  let verifyArgsAndParse = (~fragmentName as _Another: [#Another], value: Raw.t) => parse(value)
  let verifyName = (_fragmentName: [#Another]) => ()
  external unsafe_fromJson: JSON.t => Raw.t = "%identity"
  external toJson: Raw.t => JSON.t = "%identity"
}

