module MyQuery: {
  @@ocaml.warning("-32-30")
  module Raw: {
    type rec t = {nonrecursiveInput: string}
    type rec t_variables = {arg: t_variables_NonrecursiveInput}
    and t_variables_NonrecursiveInput = {
      nonNullableField: string,
      nullableArray: Nullable.t<array<Nullable.t<string>>>,
      field: Nullable.t<string>,
      enum: Nullable.t<string>,
      embeddedInput: Nullable.t<array<Nullable.t<t_variables_EmbeddedInput>>>,
      custom: Nullable.t<JSON.t>,
    }
    and t_variables_EmbeddedInput = {field: Nullable.t<string>}
  }
  type rec t = {nonrecursiveInput: string}
  type rec t_variables = {arg: t_variables_NonrecursiveInput}
  and t_variables_NonrecursiveInput = {
    nonNullableField: string,
    nullableArray: option<array<option<string>>>,
    field: option<string>,
    enum: option<[#FIRST | #SECOND | #THIRD]>,
    embeddedInput: option<array<option<t_variables_EmbeddedInput>>>,
    custom: option<JSON.t>,
  }
  and t_variables_EmbeddedInput = {field: option<string>}
  @ocaml.doc(" The GraphQL query ") let query: string
  @ocaml.doc(" Parse the JSON-compatible GraphQL data to ReasonML data types ")
  let parse: Raw.t => t
  @ocaml.doc(" Serialize the ReasonML GraphQL data that was parsed using the parse
function back to the original JSON compatible data ")
  let serialize: t => Raw.t
  let serializeVariables: t_variables => Raw.t_variables
  let serializeInputObjectNonrecursiveInput: t_variables_NonrecursiveInput => Raw.t_variables_NonrecursiveInput
  let serializeInputObjectEmbeddedInput: t_variables_EmbeddedInput => Raw.t_variables_EmbeddedInput
  let makeVariables: (~arg: t_variables_NonrecursiveInput, unit) => t_variables
  let makeInputObjectNonrecursiveInput: (
    ~nonNullableField: string,
    ~nullableArray: array<option<string>>=?,
    ~field: string=?,
    ~enum: [#FIRST | #SECOND | #THIRD]=?,
    ~embeddedInput: array<option<t_variables_EmbeddedInput>>=?,
    ~custom: JSON.t=?,
    unit,
  ) => t_variables_NonrecursiveInput
  let makeInputObjectEmbeddedInput: (~field: string=?, unit) => t_variables_EmbeddedInput
  external unsafe_fromJson: JSON.t => Raw.t = "%identity"
  external toJson: Raw.t => JSON.t = "%identity"
  external variablesToJson: Raw.t_variables => JSON.t = "%identity"
} = {
  @@ocaml.warning("-32-30")
  module Raw = {
    type rec t = {nonrecursiveInput: string}
    type rec t_variables = {arg: t_variables_NonrecursiveInput}
    and t_variables_NonrecursiveInput = {
      nonNullableField: string,
      nullableArray: Nullable.t<array<Nullable.t<string>>>,
      field: Nullable.t<string>,
      enum: Nullable.t<string>,
      embeddedInput: Nullable.t<array<Nullable.t<t_variables_EmbeddedInput>>>,
      custom: Nullable.t<JSON.t>,
    }
    and t_variables_EmbeddedInput = {field: Nullable.t<string>}
  }
  type rec t = {nonrecursiveInput: string}
  type rec t_variables = {arg: t_variables_NonrecursiveInput}
  and t_variables_NonrecursiveInput = {
    nonNullableField: string,
    nullableArray: option<array<option<string>>>,
    field: option<string>,
    enum: option<[#FIRST | #SECOND | #THIRD]>,
    embeddedInput: option<array<option<t_variables_EmbeddedInput>>>,
    custom: option<JSON.t>,
  }
  and t_variables_EmbeddedInput = {field: option<string>}
  let query = "query ($arg: NonrecursiveInput!)  {
nonrecursiveInput(arg: $arg)  
}
"
  let parse = (value): t => {
    nonrecursiveInput: {
      let value = (value: Raw.t).nonrecursiveInput
      value
    },
  }
  let serialize = (value): Raw.t => {
    let nonrecursiveInput = {
      let value = (value: t).nonrecursiveInput
      value
    }
    {nonrecursiveInput: nonrecursiveInput}
  }
  let rec serializeVariables: t_variables => Raw.t_variables = inp => {
    arg: @res.uapp
    (a => @res.uapp serializeInputObjectNonrecursiveInput(a))((inp: t_variables).arg),
  }
  and serializeInputObjectNonrecursiveInput: t_variables_NonrecursiveInput => Raw.t_variables_NonrecursiveInput = inp => {
    nonNullableField: @res.uapp (a => a)((inp: t_variables_NonrecursiveInput).nonNullableField),
    nullableArray: @res.uapp
    (
      a =>
        switch a {
        | None => Nullable.undefined
        | Some(b) =>
          Nullable.make(
            @res.uapp
            (
              @res.uapp
              a =>
                Array.map(a, b =>
                  @res.uapp
                  (
                    a =>
                      switch a {
                      | None => Nullable.undefined
                      | Some(b) => Nullable.make(@res.uapp (a => a)(b))
                      }
                  )(b)
                )
            )(b),
          )
        }
    )((inp: t_variables_NonrecursiveInput).nullableArray),
    field: @res.uapp
    (
      a =>
        switch a {
        | None => Nullable.undefined
        | Some(b) => Nullable.make(@res.uapp (a => a)(b))
        }
    )((inp: t_variables_NonrecursiveInput).field),
    enum: @res.uapp
    (
      a =>
        switch a {
        | None => Nullable.undefined
        | Some(b) =>
          Nullable.make(
            @res.uapp
            (
              a =>
                switch a {
                | #FIRST => "FIRST"
                | #SECOND => "SECOND"
                | #THIRD => "THIRD"
                }
            )(b),
          )
        }
    )((inp: t_variables_NonrecursiveInput).enum),
    embeddedInput: @res.uapp
    (
      a =>
        switch a {
        | None => Nullable.undefined
        | Some(b) =>
          Nullable.make(
            @res.uapp
            (
              @res.uapp
              a =>
                Array.map(a, b =>
                  @res.uapp
                  (
                    a =>
                      switch a {
                      | None => Nullable.undefined
                      | Some(b) =>
                        Nullable.make(
                          @res.uapp
                          (a => @res.uapp serializeInputObjectEmbeddedInput(a))(b),
                        )
                      }
                  )(b)
                )
            )(b),
          )
        }
    )((inp: t_variables_NonrecursiveInput).embeddedInput),
    custom: @res.uapp
    (
      a =>
        switch a {
        | None => Nullable.undefined
        | Some(b) => Nullable.make(@res.uapp (a => a)(b))
        }
    )((inp: t_variables_NonrecursiveInput).custom),
  }
  and serializeInputObjectEmbeddedInput: t_variables_EmbeddedInput => Raw.t_variables_EmbeddedInput = inp => {
    field: @res.uapp
    (
      a =>
        switch a {
        | None => Nullable.undefined
        | Some(b) => Nullable.make(@res.uapp (a => a)(b))
        }
    )((inp: t_variables_EmbeddedInput).field),
  }
  let makeVariables = (~arg, ()): t_variables => {arg: arg}
  and makeInputObjectNonrecursiveInput = (
    ~nonNullableField,
    ~nullableArray=?,
    ~field=?,
    ~enum=?,
    ~embeddedInput=?,
    ~custom=?,
    (),
  ): t_variables_NonrecursiveInput => {
    nonNullableField,
    nullableArray,
    field,
    enum,
    embeddedInput,
    custom,
  }
  and makeInputObjectEmbeddedInput = (~field=?, ()): t_variables_EmbeddedInput => {field: field}
  external unsafe_fromJson: JSON.t => Raw.t = "%identity"
  external toJson: Raw.t => JSON.t = "%identity"
  external variablesToJson: Raw.t_variables => JSON.t = "%identity"
}
module MyQuery2: {
  @@ocaml.warning("-32-30")
  module Raw: {
    type rec t = {
      scalarsInput: string,
      more: string,
    }
    type rec t_variables = {arg: t_variables_NonrecursiveInput, arg2: t_variables_NonrecursiveInput}
    and t_variables_NonrecursiveInput = {
      nonNullableField: string,
      nullableArray: Nullable.t<array<Nullable.t<string>>>,
      field: Nullable.t<string>,
      enum: Nullable.t<string>,
      embeddedInput: Nullable.t<array<Nullable.t<t_variables_EmbeddedInput>>>,
      custom: Nullable.t<JSON.t>,
    }
    and t_variables_EmbeddedInput = {field: Nullable.t<string>}
  }
  type rec t = {scalarsInput: string, more: string}
  type rec t_variables = {arg: t_variables_NonrecursiveInput, arg2: t_variables_NonrecursiveInput}
  and t_variables_NonrecursiveInput = {
    nonNullableField: string,
    nullableArray: option<array<option<string>>>,
    field: option<string>,
    enum: option<[#FIRST | #SECOND | #THIRD]>,
    embeddedInput: option<array<option<t_variables_EmbeddedInput>>>,
    custom: option<JSON.t>,
  }
  and t_variables_EmbeddedInput = {field: option<string>}
  @ocaml.doc(" The GraphQL query ") let query: string
  @ocaml.doc(" Parse the JSON-compatible GraphQL data to ReasonML data types ")
  let parse: Raw.t => t
  @ocaml.doc(" Serialize the ReasonML GraphQL data that was parsed using the parse
function back to the original JSON compatible data ")
  let serialize: t => Raw.t
  let serializeVariables: t_variables => Raw.t_variables
  let serializeInputObjectNonrecursiveInput: t_variables_NonrecursiveInput => Raw.t_variables_NonrecursiveInput
  let serializeInputObjectEmbeddedInput: t_variables_EmbeddedInput => Raw.t_variables_EmbeddedInput
  let makeVariables: (
    ~arg: t_variables_NonrecursiveInput,
    ~arg2: t_variables_NonrecursiveInput,
    unit,
  ) => t_variables
  let makeInputObjectNonrecursiveInput: (
    ~nonNullableField: string,
    ~nullableArray: array<option<string>>=?,
    ~field: string=?,
    ~enum: [#FIRST | #SECOND | #THIRD]=?,
    ~embeddedInput: array<option<t_variables_EmbeddedInput>>=?,
    ~custom: JSON.t=?,
    unit,
  ) => t_variables_NonrecursiveInput
  let makeInputObjectEmbeddedInput: (~field: string=?, unit) => t_variables_EmbeddedInput
  external unsafe_fromJson: JSON.t => Raw.t = "%identity"
  external toJson: Raw.t => JSON.t = "%identity"
  external variablesToJson: Raw.t_variables => JSON.t = "%identity"
} = {
  @@ocaml.warning("-32-30")
  module Raw = {
    type rec t = {
      scalarsInput: string,
      more: string,
    }
    type rec t_variables = {arg: t_variables_NonrecursiveInput, arg2: t_variables_NonrecursiveInput}
    and t_variables_NonrecursiveInput = {
      nonNullableField: string,
      nullableArray: Nullable.t<array<Nullable.t<string>>>,
      field: Nullable.t<string>,
      enum: Nullable.t<string>,
      embeddedInput: Nullable.t<array<Nullable.t<t_variables_EmbeddedInput>>>,
      custom: Nullable.t<JSON.t>,
    }
    and t_variables_EmbeddedInput = {field: Nullable.t<string>}
  }
  type rec t = {
    scalarsInput: string,
    more: string,
  }
  type rec t_variables = {arg: t_variables_NonrecursiveInput, arg2: t_variables_NonrecursiveInput}
  and t_variables_NonrecursiveInput = {
    nonNullableField: string,
    nullableArray: option<array<option<string>>>,
    field: option<string>,
    enum: option<[#FIRST | #SECOND | #THIRD]>,
    embeddedInput: option<array<option<t_variables_EmbeddedInput>>>,
    custom: option<JSON.t>,
  }
  and t_variables_EmbeddedInput = {field: option<string>}
  let query = "query ($arg: NonrecursiveInput!, $arg2: NonrecursiveInput!)  {
scalarsInput(arg: $arg)  
more: scalarsInput(arg: $arg2)  
}
"
  let parse = (value): t => {
    scalarsInput: {
      let value = (value: Raw.t).scalarsInput
      value
    },
    more: {
      let value = (value: Raw.t).more
      value
    },
  }
  let serialize = (value): Raw.t => {
    let more = {
      let value = (value: t).more
      value
    }
    and scalarsInput = {
      let value = (value: t).scalarsInput
      value
    }
    {scalarsInput, more}
  }
  let rec serializeVariables: t_variables => Raw.t_variables = inp => {
    arg: @res.uapp
    (a => @res.uapp serializeInputObjectNonrecursiveInput(a))((inp: t_variables).arg),
    arg2: @res.uapp
    (a => @res.uapp serializeInputObjectNonrecursiveInput(a))((inp: t_variables).arg2),
  }
  and serializeInputObjectNonrecursiveInput: t_variables_NonrecursiveInput => Raw.t_variables_NonrecursiveInput = inp => {
    nonNullableField: @res.uapp (a => a)((inp: t_variables_NonrecursiveInput).nonNullableField),
    nullableArray: @res.uapp
    (
      a =>
        switch a {
        | None => Nullable.undefined
        | Some(b) =>
          Nullable.make(
            @res.uapp
            (
              @res.uapp
              a =>
                Array.map(a, b =>
                  @res.uapp
                  (
                    a =>
                      switch a {
                      | None => Nullable.undefined
                      | Some(b) => Nullable.make(@res.uapp (a => a)(b))
                      }
                  )(b)
                )
            )(b),
          )
        }
    )((inp: t_variables_NonrecursiveInput).nullableArray),
    field: @res.uapp
    (
      a =>
        switch a {
        | None => Nullable.undefined
        | Some(b) => Nullable.make(@res.uapp (a => a)(b))
        }
    )((inp: t_variables_NonrecursiveInput).field),
    enum: @res.uapp
    (
      a =>
        switch a {
        | None => Nullable.undefined
        | Some(b) =>
          Nullable.make(
            @res.uapp
            (
              a =>
                switch a {
                | #FIRST => "FIRST"
                | #SECOND => "SECOND"
                | #THIRD => "THIRD"
                }
            )(b),
          )
        }
    )((inp: t_variables_NonrecursiveInput).enum),
    embeddedInput: @res.uapp
    (
      a =>
        switch a {
        | None => Nullable.undefined
        | Some(b) =>
          Nullable.make(
            @res.uapp
            (
              @res.uapp
              a =>
                Array.map(a, b =>
                  @res.uapp
                  (
                    a =>
                      switch a {
                      | None => Nullable.undefined
                      | Some(b) =>
                        Nullable.make(
                          @res.uapp
                          (a => @res.uapp serializeInputObjectEmbeddedInput(a))(b),
                        )
                      }
                  )(b)
                )
            )(b),
          )
        }
    )((inp: t_variables_NonrecursiveInput).embeddedInput),
    custom: @res.uapp
    (
      a =>
        switch a {
        | None => Nullable.undefined
        | Some(b) => Nullable.make(@res.uapp (a => a)(b))
        }
    )((inp: t_variables_NonrecursiveInput).custom),
  }
  and serializeInputObjectEmbeddedInput: t_variables_EmbeddedInput => Raw.t_variables_EmbeddedInput = inp => {
    field: @res.uapp
    (
      a =>
        switch a {
        | None => Nullable.undefined
        | Some(b) => Nullable.make(@res.uapp (a => a)(b))
        }
    )((inp: t_variables_EmbeddedInput).field),
  }
  let makeVariables = (~arg, ~arg2, ()): t_variables => {arg, arg2}
  and makeInputObjectNonrecursiveInput = (
    ~nonNullableField,
    ~nullableArray=?,
    ~field=?,
    ~enum=?,
    ~embeddedInput=?,
    ~custom=?,
    (),
  ): t_variables_NonrecursiveInput => {
    nonNullableField,
    nullableArray,
    field,
    enum,
    embeddedInput,
    custom,
  }
  and makeInputObjectEmbeddedInput = (~field=?, ()): t_variables_EmbeddedInput => {field: field}
  external unsafe_fromJson: JSON.t => Raw.t = "%identity"
  external toJson: Raw.t => JSON.t = "%identity"
  external variablesToJson: Raw.t_variables => JSON.t = "%identity"
}

